const through2 = require('through2'),
      StringDecoder = require('string_decoder').StringDecoder,
      decoder = new StringDecoder('utf8');

module.exports = function ngAotCompliant(options)
{
    return through2.obj(function(vinyl, enc, callback)
    {
        if(vinyl.isDirectory())
        {
            callback(null, vinyl);

            return;
        }
        
        var source = decoder.end(vinyl.contents);
        var gatheredData = 
        {
            routes: [],
            redirects: [],
            componentName: null,
            path: null
        };

        if(options && options.mainFilename && options.serverModule && options.serverModuleFilename && vinyl.path.indexOf(options.mainFilename) >= 0)
        {
            console.log('Preparing main entry server side rendering file.');
            source = source.replace(/renderModule/gm, "renderModuleFactory");
            source = source.replace(new RegExp(options.serverModuleFilename, 'gm'), options.serverModuleFilename + ".ngfactory");
            source = source.replace(new RegExp(options.serverModule, 'gm'), options.serverModule + "NgFactory");
        } 

        if(source.indexOf("extractRoutes(") >= 0)
        {
            var componentRouteHelperRegex = /extractRoutes\(\[((?:.|\n|\r\n)+)\]\)/gm;
            var matches = componentRouteHelperRegex.exec(source);

            var components = matches[1].replace(/\s+/g, "").split(",").map(itm => "..." + itm + ".ngRoutes").join(",");

            source = source.replace(componentRouteHelperRegex, "[" + components + "]");
        }

        //process AOT transformations
        if(source.indexOf("//@aot") >= 0)
        {
            var instructions = {};
            var instructionsMatches = /@aot\s(.*?)$/m.exec(source)[1].split(' ');
            
            instructionsMatches.forEach(instruction =>
            {
                let matches;

                if((matches = /([a-z]+)\((.*?)\)/i.exec(instruction)))
                {
                    instructions[matches[1]] = matches[2].split(',');
                }
                else
                {
                    instructions[instruction] = true;
                }
            });

            /**
             * Available instructions:
             * 
             * platform - transforms platformDynamic and import platformDynamic into platform
             * module(<moduleName>) - transforms module import into ngFactory import
             * bootstrap - transforms bootstrap module into bootstrap module factory
             */

            //updates usage of platformDynamic
            if('platform' in instructions)
            {
                source = source.replace(/(import.*?from\s+)(?:'|")(@angular\/platform-.*)-dynamic(?:'|")/m, "$1'$2'");
                source = source.replace(/(platform[A-Z][a-z]+)Dynamic/g, "$1");
            }

            //updates usage of module import
            if('module' in instructions)
            {
                source = source.replace(new RegExp(`(import\\s+{.*?${instructions['module'][0]}.*?}\\s+from\\s+)(?:'|")(.*?)(?:'|")`, 'm'), "$1'$2.ngfactory'");
                source = source.replace(new RegExp(instructions['module'][0], 'g'), `${instructions['module'][0]}NgFactory`);
            }

            //updates usage of bootstrap module
            if('bootstrap' in instructions)
            {
                source = source.replace(/bootstrapModule\(/g, "bootstrapModuleFactory(");
            }
        }

        //module contains decorator routes
        if(source.indexOf("@ComponentRedirectRoute") >= 0 || source.indexOf("@ComponentRoute") >= 0)
        {
            var routesGathered = false;
            var generate = false;
            var nextStartBody = false;
            var index = 0;

            var sourceParsed = source.split('\n');
      	    var beforeContext = null;
            var beforeContextType = null;

            sourceParsed.slice(0).forEach(function(line)
            {
                var componentRedirectRouteRegex = /@ComponentRedirectRoute\((?:'|")(.*?)(?:'|")(?:\s*,\s*(?:'|")(.*?)(?:'|")(?:\s*,\s*(true|false))?)?\)/;
                var componentRedirectRouteBeginningRegex = /@ComponentRedirectRoute/;
                var componentRouteRegex = /@ComponentRoute\(({.*})\)/;
                var componentRouteBeginningRegex = /@ComponentRoute/;
                var componentRoutePathRegex = /path:\s*(?:'|")(.*?)(?:'|")/g;
                var componentRegex = /export\s+(?:abstract\s+)?class\s+(.*?)(?:\s+.*?)?({)/;
                var componentBeginningRegex = /export\s+(?:abstract\s+)?class\s+/;

                //handle multiline component declaration
                if (componentBeginningRegex.test(line) &&
                    !componentRegex.test(line) &&
                    beforeContext === null)
                {
                    beforeContextType = "Component";
                    beforeContext = line;
                    index++;
                    return;
                }

                //handle multiline ComponentRoute declaration
                if (componentRouteBeginningRegex.test(line) &&
                    !componentRouteRegex.test(line) &&
                    beforeContext === null)
                {
                    beforeContextType = "ComponentRoute";
                    beforeContext = line;
                    index++;
                    return;
                }

                //handle multiline ComponentRedirectRoute declaration
                if (componentRedirectRouteBeginningRegex.test(line) &&
                    !componentRedirectRouteRegex.test(line) &&
                    beforeContext === null)
                {
                    beforeContextType = "ComponentRedirectRoute";
                    beforeContext = line;
                    index++;
                    return;
                }

                if (beforeContext !== null)
                {
                    var regex = componentRouteRegex;

                    if (beforeContextType == "ComponentRedirectRoute") 
                    {
                        regex = componentRedirectRouteRegex;
                    }
                    else if (beforeContextType == "Component")
                    {
                        regex = componentRegex;
                    }

                    line = (beforeContext + line).replace(/[\r\n]+/g, " ");

                    if (!regex.test(line)) 
                    {
                        beforeContext = line;
                        index++;
                        return;
                    }
                    else
                    {
                        beforeContext = null;
                        beforeContextType = null;
                    }
                }
                
                var matches = null;

                //get redirect data
                if((matches = componentRedirectRouteRegex.exec(line)))
                {
                    routesGathered = true;

                    var redirect = 
                    {
                        path: matches[1]
                    };

                    if(matches[2] !== undefined)
                    {
                        redirect.redirectTo = matches[2];
                    }

                    if(matches[3] !== undefined)
                    {
                        redirect.pathMatch = matches[3] == 'true' ? "full" : "prefix";
                    }
                    else
                    {
                        redirect.pathMatch = "prefix";
                    }

                    gatheredData.redirects.push(redirect);

                    index++;

                    return;
                }

                //get route data
                if((matches = componentRouteRegex.exec(line)))
                {
                    routesGathered = true;

                    var route = matches[1];
                    var pathMatch = null;
                    
                    if(!(pathMatch = componentRoutePathRegex.exec(route)))
                    {
                        throw new Error("No Path specified! for route");

                        return;
                    }

                    gatheredData.path = pathMatch[1];
                    gatheredData.routes.push(route);

                    index++;

                    return;
                }

                //extract component
                if((matches = componentRegex.exec(line)))
                {
                    gatheredData.componentName = matches[1];

                    if(matches[2] == "{")
                    {
                        generate = true;
                    }
                    else
                    {
                        nextStartBody = true;
                    }

                    index++;

                    return;
                }

                if(nextStartBody)
                {
                    nextStartBody = false;
                    generate = true;

                    index++;

                    return;
                }

                if(generate)
                {
                    if(gatheredData.routes.length < 1)
                    {
                        throw new Error("Missing 'ComponentRoute'!");

                        return;
                    }

                    if(gatheredData.routes.length > 1 && gatheredData.redirects.filter(itm => !itm.redirectTo).length > 0)
                    {
                        throw new Error("Multiple routes defined. Unable to set proper redirect!");

                        return;
                    }

                    var resultRoutes = [];

                    gatheredData.redirects.forEach(function(redir)
                    {
                        if(redir.redirectTo === undefined)
                        {
                            redir.redirectTo = gatheredData.path;
                        }

                        resultRoutes.push(JSON.stringify(redir));
                    });

                    gatheredData.routes.reverse().forEach(function(rt)
                    {
                        resultRoutes.push(rt.replace(/(.*)}/g, "$1") + ", component: " + gatheredData.componentName + "}");
                    });

                    var data = "public static ngRoutes = [" + resultRoutes.join(", ") + "];";;

                    sourceParsed.splice(index, 0, data);

                    //reset all data
                    gatheredData = 
                    {
                        routes: [],
                        redirects: [],
                        componentName: null,
                        path: null
                    };

                    generate = false;
                    index += 2;

                    return;
                }

                index++;
            });

            source = sourceParsed.join('\n');
        }

        vinyl.contents = Buffer.from(source);

        callback(null, vinyl);
    });
}